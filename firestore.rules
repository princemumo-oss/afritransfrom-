/**
 * Core Philosophy: This ruleset enforces a strict, privacy-focused security model for a social media application.
 * The default posture is deny-all, with access granted explicitly based on user ownership or participation. It prioritizes
 * protecting user data, ensuring that users can only access and modify their own information or data explicitly shared with them.
 *
 * Data Structure: User data is primarily stored under `/users/{userId}`, creating a clear ownership hierarchy.
 * For performance and security, a denormalized `/global_posts` collection is used for public feeds, while private
 * interactions like friend requests and messages are handled in dedicated top-level collections with specific access controls.
 *
 * Key Security Decisions:
 * - User profiles (`/users/{userId}`) are strictly private. A user can only read their own profile, not others'.
 * - Listing all users (`/users`) is explicitly disallowed to protect user privacy.
 * - The main post feed (`/global_posts`) is readable by any signed-in user, but write operations are restricted to the post's author.
 * - Friend requests are only visible and actionable by the sender and receiver.
 * - Direct message access is controlled by a denormalized list of participants on a parent `chat` document, avoiding complex lookups.
 *
 * Denormalization for Authorization: The ruleset relies on denormalized fields for efficient and secure authorization checks.
 * - The `/global_posts/{postId}` documents must contain an `authorId` field.
 * - Access to message subcollections depends on a `members` array/map on the parent `/users/{userId}/chats/{chatId}` document.
 * - Friend requests contain `requesterId` and `receiverId` fields to grant access directly.
 *
 * Structural Segregation: The design separates private user-specific posts (`/users/{userId}/posts`) from the public feed
 * (`/global_posts`). This allows for secure management of personal data while enabling efficient, public listing for the application's main feed.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions for Reusability and Clarity

    /**
     * Checks if the currently authenticated user's UID matches the provided userId.
     * This is the fundamental check for resource ownership.
     */
    function isOwner(userId) {
      return request.auth != null && request.auth.uid == userId;
    }

    /**
     * Verifies that the user is signed in. Used for general access control.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Ensures a document exists before allowing an update or delete operation.
     * This prevents modifying or deleting non-existent data.
     */
    function documentExists() {
      return resource != null;
    }

    /**
     * A composite function for update/delete operations on owned documents.
     * Combines ownership check with an existence check for robustness.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && documentExists();
    }

    /**
     * Checks if a user is either the requester or receiver of a friend request.
     */
    function isFriendRequestParticipant(friendRequest) {
      return isSignedIn() && (request.auth.uid == friendRequest.requesterId || request.auth.uid == friendRequest.receiverId);
    }
    
    /**
     * Checks if a user is a member of a chat by reading the parent chat document.
     * This uses a `get()` call, which is efficient for securing subcollections.
     * Assumes the parent chat document has a `members` array of user UIDs.
     */
    function isMemberOfChat(userId, chatId) {
      return isSignedIn() && request.auth.uid in get(/databases/$(database)/documents/users/$(userId)/chats/$(chatId)).data.members;
    }

    /**
     * @description Manages user profile documents.
     * @path /users/{userId}
     * @allow (create) - A new user creating their own profile document.
     * @deny (get) - User 'B' trying to read the profile of user 'A'.
     * @principle Restricts access to a user's own data tree. A user's profile is considered private.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false; // Disallow listing all users for privacy
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages a user's private collection of their own posts. This is for management, not for the public feed.
     * @path /users/{userId}/posts/{postId}
     * @allow (create, list, delete) - The user managing their own posts.
     * @deny (create, update, delete) - Any user other than the owner trying to modify posts.
     * @principle Enforces strict ownership within a user's private data tree.
     */
    match /users/{userId}/posts/{postId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.authorId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.authorId == resource.data.authorId;
      allow delete: if isExistingOwner(userId);
    }
    
    /**
     * @description Manages the chat documents. This path is inferred from the messages subcollection.
     * @path /users/{userId}/chats/{chatId}
     * @allow (get, list, update) - A user who is a member of the chat accessing it.
     * @deny (get) - A user trying to read a chat they are not a member of.
     * @principle Secures a shared resource by checking for membership in a denormalized `members` array on the document itself.
     */
    match /users/{userId}/chats/{chatId} {
      allow get, list: if isMemberOfChat(userId, chatId);
      allow create: if isSignedIn() && request.auth.uid in request.resource.data.members;
      allow update: if documentExists() && isMemberOfChat(userId, chatId);
      allow delete: if documentExists() && isMemberOfChat(userId, chatId);
    }

    /**
     * @description Manages direct messages within a chat.
     * @path /users/{userId}/chats/{chatId}/messages/{messageId}
     * @allow (create) - A member of the chat sending a message.
     * @deny (list) - A non-member trying to list messages in a private chat.
     * @principle Secures a subcollection by referencing a denormalized access list on its parent document.
     */
    match /users/{userId}/chats/{chatId}/messages/{messageId} {
      allow get, list: if isMemberOfChat(userId, chatId);
      allow create: if isMemberOfChat(userId, chatId) && request.resource.data.senderId == request.auth.uid;
      allow update, delete: if false; // Messages are typically immutable
    }

    /**
     * @description Manages the public, denormalized feed of all posts.
     * @path /global_posts/{postId}
     * @allow (get, list) - Any signed-in user viewing the main feed.
     * @deny (create) - A user trying to create a post with a mismatched `authorId`.
     * @principle Implements "Public Read with Owner-Only Writes" pattern for a global feed.
     */
    match /global_posts/{postId} {
      allow get, list: if isSignedIn();
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if documentExists() && isOwner(resource.data.authorId);
      allow delete: if documentExists() && isOwner(resource.data.authorId);
    }

    /**
     * @description Manages friend requests between users.
     * @path /friend_requests/{friendRequestId}
     * @allow (get) - The user who sent the request or the user who received it.
     * @deny (list) - Listing all friend requests in the system is denied for privacy.
     * @principle Secures a document based on multiple participant fields (`requesterId`, `receiverId`).
     */
    match /friend_requests/{friendRequestId} {
      allow get: if documentExists() && isFriendRequestParticipant(resource.data);
      allow list: if false; // Prevent querying all requests
      allow create: if isSignedIn() && request.resource.data.requesterId == request.auth.uid && request.resource.data.requesterId != request.resource.data.receiverId;
      // The receiver can accept/reject the request
      allow update: if documentExists() && isOwner(resource.data.receiverId);
      // The requester can cancel (delete) the request
      allow delete: if documentExists() && isOwner(resource.data.requesterId);
    }

    /**
     * @description Manages 'like' actions on posts.
     * @path /likes/{likeId}
     * @allow (create) - A signed-in user liking a post.
     * @deny (update) - Likes are immutable; they are created or deleted.
     * @principle Enforces document ownership for writes while allowing reads for signed-in users (e.g., to display like counts).
     */
    match /likes/{likeId} {
      allow get, list: if isSignedIn();
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if false;
      allow delete: if documentExists() && isOwner(resource.data.userId);
    }
  }
}